Introduction  介绍
1. Installation  1. 安装
2. Tutorial  2. 教程
3. Project Layout
3. 项目布局
4. Bindings  4. 绑定
5. Python Metadata
5. Python 元数据
6. Configuration
6. 配置
7. Environment Variables
7. 环境变量
8. Local Development
8. 本地发展
8.1. Import Hook
8.1. 导入 Hook
9. Distribution  9. 分发
10. Sphinx Integration
10. 狮身人面像集成
11. Migration Guide
11. 迁移指南
12. Changelog  12. 更改日志
13. Contributing
13. 贡献
13.1. Platform Support
13.1. 平台支持


Maturin User Guide  马图林用户指南
  
Project Layout  项目布局
Maturin expects a particular project layout depending on the contents of the package.
Maturin 需要特定的项目布局，具体取决于包的内容。

Pure Rust project  Pure Rust 项目
For a pure Rust project, the structure is as expected and what you get from cargo new:
对于一个纯 Rust 项目，结构是预期的，你从 cargo new 中得到的就是：

my-rust-project/
├── Cargo.toml
├── pyproject.toml  # required for maturin configuration
└── src
    ├── lib.rs  # default for library crates
    └── main.rs  # default for binary crates
Maturin will add a necessary __init__.py to the package when building the wheel. For convenience, this file includes the following:
Maturin 将在构建轮子时向包中添加必要的 __init__.py。为方便起见，此文件包括以下内容：

from .my_project import *

__doc__ = my_project.__doc__
if hasattr(my_project, "__all__"):
    __all__ = my_project.__all__
such that the module functions may be called directly with:
这样就可以直接调用模块函数：

import my_project
my_project.foo()
rather than:  而不是：

from my_project import my_project
Note: there is currently no way to tell maturin to include extra data (e.g. package_data in setuptools) for a pure Rust project. Instead, consider using the layout described below for the mixed Rust/Python project.
注意 ：目前无法告诉 maturin 包含额外的数据（例如 package_data 在 setuptools 中）用于纯 Rust 项目。相反，请考虑对 Rust/Python 混合项目使用下面描述的布局。

Mixed Rust/Python project
Rust/Python 混合项目
To create a mixed Rust/Python project, add a directory with your package name (i.e. matching lib.name in your Cargo.toml) to contain the Python source:
要创建一个混合的 Rust/Python 项目，请添加一个包含您的包名称的目录（即 Cargo.toml 中的匹配 lib.name）以包含 Python 源代码：

my-rust-and-python-project
├── Cargo.toml
├── my_project  # <<< add this directory and put Python code in here
│   ├── __init__.py
│   └── bar.py
├── pyproject.toml
├── README.md
└── src
    └── lib.rs
Note that in a mixed Rust/Python project, maturin does not modify the existing __init__.py in the root package, so now to import the rust module in Python you must use:
请注意，在混合 Rust/Python 项目中，maturin 不会修改根包中的现有 __init__.py，因此现在要在 Python 中导入 rust 模块，您必须使用：

from my_project import my_project
You can modify __init__.py yourself (see above) if you would like to import Rust functions from a higher-level namespace.
如果你想从更高级别的命名空间导入 Rust 函数，你可以自己修改 __init__.py（见上文）。

You can specify a different python source directory in pyproject.toml by setting tool.maturin.python-source, for example
例如，您可以通过设置 tool.maturin.python-source 在 pyproject.toml 中指定不同的 python 源目录

pyproject.toml  pyproject.toml 文件

[tool.maturin]
python-source = "python"
then the project structure would look like this:
则 Project 结构将如下所示：

my-rust-and-python-project
├── Cargo.toml
├── python
│   └── my_project
│       ├── __init__.py
│       └── bar.py
├── pyproject.toml
├── README.md
└── src
    └── lib.rs
Note  注意

This structure is recommended to avoid a common ImportError pitfall
建议使用此结构以避免常见的 ImportError 陷阱

Alternate Python source directory (src layout)
备用 Python 源目录 （src layout）
Having a directory with package_name in the root of the project can occasionally cause confusion as Python allows importing local packages and modules. A popular way to avoid this is with the src-layout, where the Python package is nested within a src directory. Unfortunately this interferes with the structure of a typical Rust project. Fortunately, Python is not particular about the name of the parent source directory.
在项目的根目录中拥有带有 package_name 的目录偶尔会引起混淆，因为 Python 允许导入本地包和模块。避免这种情况的一种流行方法是使用 src-layout，其中 Python 包嵌套在 src 目录中。不幸的是，这干扰了典型 Rust 项目的结构。幸运的是，Python 对父源目录的名称并不特别。

maturin will detect the following src layout automatically:
maturin 将自动检测以下 src 布局：

my-rust-and-python-project
├── src  # put python code in src folder
│   └── my_project
│       ├── __init__.py
│       └── bar.py
├── pyproject.toml
├── README.md
└── rust # put rust code in rust folder
    |── Cargo.toml
    └── src
        └── lib.rs
Import Rust as a submodule of your project
If the Python module created by Rust has the same name as the Python package in a mixed Rust/Python project, IDEs might get confused. You might also want to discourage end users from using the Rust functions directly by giving it a different name, say '_my_project'. This can be done by adding module-name = <package name>.<rust pymodule name> to the [tool.maturin] in your pyproject.toml. For example:

[tool.maturin]
module-name = "my_project._my_project"
Update the module name in lib.rs to match the expected module name:

#[pymodule]
- fn my_project(...)
+ fn _my_project(...)
If you are using the pyo3 bindings, you can alternatively add #[pyo3(name = ...)] to the #[pymodule] declaration:

#[pymodule]
+ #[pyo3(name = "_my_project")]
fn my_project(...)
You can then import your Rust module inside your Python source as follows:

from my_project import _my_project
IDEs can then recognize the _my_project module as separate from your main Python source module. This allows for code completion of the types inside your Rust Python module for certain IDEs.

Adding Python type information
To distribute typing information, you need to add:

an empty marker file called py.typed in the root of the Python package
inline types in Python files and/or .pyi "stub" files
In a pure Rust project, add type stubs in a <module_name>.pyi file in the project root. Maturin will automatically include this file along with the required py.typed file for you.

my-rust-project/
├── Cargo.toml
├── my_project.pyi  # <<< add type stubs for Rust functions in the my_project module here
├── pyproject.toml
└── src
    └── lib.rs
In a mixed Rust/Python project, additional files in the Python source dir (but not in .gitignore) will be automatically included in the build outputs (source distribution and/or wheel). Type information can be therefore added to the root Python package directory as you might do in a pure Python package. This requires you to add the py.typed marker file yourself.

my-project
├── Cargo.toml
├── python
│   └── my_project
│       ├── __init__.py
│       ├── py.typed  # <<< add this empty file
│       ├── my_project.pyi  # <<< add type stubs for Rust functions in the my_project module here
│       ├── bar.pyi  # <<< add type stubs for bar.py here OR type bar.py inline
│       └── bar.py
├── pyproject.toml
├── README.md
└── src
    └── lib.rs
Data
You can add wheel data by creating a <module_name>.data folder or setting its location as data in pyproject.toml under [tool.maturin] or in Cargo.toml under [project.metadata.maturin].

The data folder may have the following subfolder:

data: The contents of this folder will simply be unpacked into the virtualenv
scripts: Treated similar to entry points, files in there are installed as standalone executable
headers: For .h C header files
purelib: This also exists, but seems to be barely used
platlib: This also exists, but seems to be barely used
If you add a symlink in the data directory, we'll include the actual file so you have more flexibility.

