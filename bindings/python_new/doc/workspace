第零步：备份！
在做任何重构之前，请务必要备份你的项目！如果你在使用 git，这是最简单的：

Bash

git add .
git commit -m " sauvegarde: Avant la restructuration en workspace"
第一步：改造“总管家” - 根 Cargo.toml
打开你项目最外层的那个 Cargo.toml 文件。

它现在看起来可能像这样：

Ini, TOML

[package]
name = "my_big_project"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = "1.0"
tokio = { version = "1", features = ["full"] }
# ... 一大堆依赖
把它改造成一个虚拟清单。删除 [package] 部分，删除所有的 [dependencies]（别担心，我们稍后会把它们移到各自的子包里），然后添加 [workspace] 部分。

改造后它应该看起来像这样：

Ini, TOML

[workspace]
members = [
    # 这里先留空，我们稍后会一个一个把成员加上
]
resolver = "2" # 推荐使用

# 注意：顶层的 [dependencies] 也可以保留，作为工作区共享依赖
# 但为了清晰，我们先假设全部移到子包里
第二步：创建第一个子包并迁移代码
我们先拿一个二进制文件开刀。假设你的老 src/ 目录里有一个 main_binary_one.rs。

在项目根目录创建一个新的文件夹来存放所有的包，这能让结构更清晰。比如叫 crates 或 packages。

Bash

mkdir crates
为你的第一个二进制包创建目录结构：

Bash

mkdir crates/binary_one
mkdir crates/binary_one/src
移动并重命名代码文件：把老的二进制文件移动到新位置，并重命名为 main.rs（这是二进制包的默认入口文件名）。

Bash

# 假设你原来的文件叫 main_binary_one.rs
mv src/main_binary_one.rs crates/binary_one/src/main.rs
为 binary_one 手动创建它自己的 Cargo.toml 文件：

Bash

touch crates/binary_one/Cargo.toml
编辑这个新的 crates/binary_one/Cargo.toml，填上它的包定义和它真正需要的依赖。你需要对照第零步备份的老 Cargo.toml，把这个二进制包用到的依赖项“复制黏贴”过来。

Ini, TOML

# 文件: crates/binary_one/Cargo.toml
[package]
name = "binary_one"
version = "0.1.0"
edition = "2021"

[dependencies]
# 只放 binary_one 需要的依赖！
serde = "1.0" 
第三步：向工作区注册新成员
回到根目录的 Cargo.toml，把我们刚创建的 binary_one 添加到 members 列表里。

Ini, TOML

# 文件: ./Cargo.toml (根目录)
[workspace]
members = [
    "crates/binary_one", # 注册新成员
]
resolver = "2"
第四步：测试与迭代
现在，你的工作区里已经有了一个成员。在项目的根目录运行检查命令：

Bash

cargo check -p binary_one
cargo 此时可能会报错，告诉你 binary_one 还缺少某些依赖。这非常正常！根据报错信息，回到 crates/binary_one/Cargo.toml 文件里，把缺少的依赖从老的 Cargo.toml 中添加过来，直到 cargo check -p binary_one 能够成功通过。

第五步：重复！
一旦你的第一个包迁移成功，你就掌握了这个流程。现在，对你原来 src/ 目录下的其他二进制文件，重复第二步、第三步和第四步。每完成一个，你的工作区就壮大一分。